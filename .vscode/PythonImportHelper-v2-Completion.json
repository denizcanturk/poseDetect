[
    {
        "label": "*",
        "importPath": "utils_v2",
        "description": "utils_v2",
        "isExtraImport": true,
        "detail": "utils_v2",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "cv2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cv2",
        "description": "cv2",
        "detail": "cv2",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "mediapipe",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mediapipe",
        "description": "mediapipe",
        "detail": "mediapipe",
        "documentation": {}
    },
    {
        "label": "serial",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "serial",
        "description": "serial",
        "detail": "serial",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "poseLibrary",
        "description": "poseLibrary",
        "isExtraImport": true,
        "detail": "poseLibrary",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "2",
        "description": "2",
        "peekOfCode": "def main():\n    hands = mp_hands.Hands(\n        min_detection_confidence=0.7, min_tracking_confidence=0.7)\n    hand_landmark_drawing_spec = mp_drawing.DrawingSpec(thickness=5, circle_radius=5)\n    hand_connection_drawing_spec = mp_drawing.DrawingSpec(thickness=10, circle_radius=10)\n    cap = cv2.VideoCapture(0)\n    pts = deque(maxlen=64)\n    while cap.isOpened():\n        idx_to_coordinates = {}\n        ret, image = cap.read()",
        "detail": "2",
        "documentation": {}
    },
    {
        "label": "mp_drawing",
        "kind": 5,
        "importPath": "2",
        "description": "2",
        "peekOfCode": "mp_drawing = mp.solutions.drawing_utils\nmp_hands = mp.solutions.hands\ndef main():\n    hands = mp_hands.Hands(\n        min_detection_confidence=0.7, min_tracking_confidence=0.7)\n    hand_landmark_drawing_spec = mp_drawing.DrawingSpec(thickness=5, circle_radius=5)\n    hand_connection_drawing_spec = mp_drawing.DrawingSpec(thickness=10, circle_radius=10)\n    cap = cv2.VideoCapture(0)\n    pts = deque(maxlen=64)\n    while cap.isOpened():",
        "detail": "2",
        "documentation": {}
    },
    {
        "label": "mp_hands",
        "kind": 5,
        "importPath": "2",
        "description": "2",
        "peekOfCode": "mp_hands = mp.solutions.hands\ndef main():\n    hands = mp_hands.Hands(\n        min_detection_confidence=0.7, min_tracking_confidence=0.7)\n    hand_landmark_drawing_spec = mp_drawing.DrawingSpec(thickness=5, circle_radius=5)\n    hand_connection_drawing_spec = mp_drawing.DrawingSpec(thickness=10, circle_radius=10)\n    cap = cv2.VideoCapture(0)\n    pts = deque(maxlen=64)\n    while cap.isOpened():\n        idx_to_coordinates = {}",
        "detail": "2",
        "documentation": {}
    },
    {
        "label": "pts",
        "kind": 5,
        "importPath": "3",
        "description": "3",
        "peekOfCode": "pts = deque(maxlen=64)\nLower_green = np.array([110,50,50])\nUpper_green = np.array([130,255,255])\nwhile True:\n\tret, img=cap.read()\n\thsv=cv2.cvtColor(img,cv2.COLOR_BGR2HSV)\n\tkernel=np.ones((5,5),np.uint8)\n\tmask=cv2.inRange(hsv,Lower_green,Upper_green)\n\tmask = cv2.erode(mask, kernel, iterations=2)\n\tmask=cv2.morphologyEx(mask,cv2.MORPH_OPEN,kernel)",
        "detail": "3",
        "documentation": {}
    },
    {
        "label": "Lower_green",
        "kind": 5,
        "importPath": "3",
        "description": "3",
        "peekOfCode": "Lower_green = np.array([110,50,50])\nUpper_green = np.array([130,255,255])\nwhile True:\n\tret, img=cap.read()\n\thsv=cv2.cvtColor(img,cv2.COLOR_BGR2HSV)\n\tkernel=np.ones((5,5),np.uint8)\n\tmask=cv2.inRange(hsv,Lower_green,Upper_green)\n\tmask = cv2.erode(mask, kernel, iterations=2)\n\tmask=cv2.morphologyEx(mask,cv2.MORPH_OPEN,kernel)\n\t#mask=cv2.morphologyEx(mask,cv2.MORPH_CLOSE,kernel)",
        "detail": "3",
        "documentation": {}
    },
    {
        "label": "Upper_green",
        "kind": 5,
        "importPath": "3",
        "description": "3",
        "peekOfCode": "Upper_green = np.array([130,255,255])\nwhile True:\n\tret, img=cap.read()\n\thsv=cv2.cvtColor(img,cv2.COLOR_BGR2HSV)\n\tkernel=np.ones((5,5),np.uint8)\n\tmask=cv2.inRange(hsv,Lower_green,Upper_green)\n\tmask = cv2.erode(mask, kernel, iterations=2)\n\tmask=cv2.morphologyEx(mask,cv2.MORPH_OPEN,kernel)\n\t#mask=cv2.morphologyEx(mask,cv2.MORPH_CLOSE,kernel)\n\tmask = cv2.dilate(mask, kernel, iterations=1)",
        "detail": "3",
        "documentation": {}
    },
    {
        "label": "\tmask",
        "kind": 5,
        "importPath": "3",
        "description": "3",
        "peekOfCode": "\tmask = cv2.erode(mask, kernel, iterations=2)\n\tmask=cv2.morphologyEx(mask,cv2.MORPH_OPEN,kernel)\n\t#mask=cv2.morphologyEx(mask,cv2.MORPH_CLOSE,kernel)\n\tmask = cv2.dilate(mask, kernel, iterations=1)\n\tres=cv2.bitwise_and(img,img,mask=mask)\n\tcnts,heir=cv2.findContours(mask.copy(),cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)[-2:]\n\tcenter = None\n\tif len(cnts) > 0:\n\t\tc = max(cnts, key=cv2.contourArea)\n\t\t((x, y), radius) = cv2.minEnclosingCircle(c)",
        "detail": "3",
        "documentation": {}
    },
    {
        "label": "\tmask",
        "kind": 5,
        "importPath": "3",
        "description": "3",
        "peekOfCode": "\tmask = cv2.dilate(mask, kernel, iterations=1)\n\tres=cv2.bitwise_and(img,img,mask=mask)\n\tcnts,heir=cv2.findContours(mask.copy(),cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)[-2:]\n\tcenter = None\n\tif len(cnts) > 0:\n\t\tc = max(cnts, key=cv2.contourArea)\n\t\t((x, y), radius) = cv2.minEnclosingCircle(c)\n\t\tM = cv2.moments(c)\n\t\tcenter = (int(M[\"m10\"] / M[\"m00\"]), int(M[\"m01\"] / M[\"m00\"]))\n\t\tif radius > 5:",
        "detail": "3",
        "documentation": {}
    },
    {
        "label": "\tcenter",
        "kind": 5,
        "importPath": "3",
        "description": "3",
        "peekOfCode": "\tcenter = None\n\tif len(cnts) > 0:\n\t\tc = max(cnts, key=cv2.contourArea)\n\t\t((x, y), radius) = cv2.minEnclosingCircle(c)\n\t\tM = cv2.moments(c)\n\t\tcenter = (int(M[\"m10\"] / M[\"m00\"]), int(M[\"m01\"] / M[\"m00\"]))\n\t\tif radius > 5:\n\t\t\tcv2.circle(img, (int(x), int(y)), int(radius),(0, 255, 255), 2)\n\t\t\tcv2.circle(img, center, 5, (0, 0, 255), -1)\n\tpts.appendleft(center)",
        "detail": "3",
        "documentation": {}
    },
    {
        "label": "\t\tc",
        "kind": 5,
        "importPath": "3",
        "description": "3",
        "peekOfCode": "\t\tc = max(cnts, key=cv2.contourArea)\n\t\t((x, y), radius) = cv2.minEnclosingCircle(c)\n\t\tM = cv2.moments(c)\n\t\tcenter = (int(M[\"m10\"] / M[\"m00\"]), int(M[\"m01\"] / M[\"m00\"]))\n\t\tif radius > 5:\n\t\t\tcv2.circle(img, (int(x), int(y)), int(radius),(0, 255, 255), 2)\n\t\t\tcv2.circle(img, center, 5, (0, 0, 255), -1)\n\tpts.appendleft(center)\n\tfor i in range (1,len(pts)):\n\t\tif pts[i-1]is None or pts[i] is None:",
        "detail": "3",
        "documentation": {}
    },
    {
        "label": "\t\tM",
        "kind": 5,
        "importPath": "3",
        "description": "3",
        "peekOfCode": "\t\tM = cv2.moments(c)\n\t\tcenter = (int(M[\"m10\"] / M[\"m00\"]), int(M[\"m01\"] / M[\"m00\"]))\n\t\tif radius > 5:\n\t\t\tcv2.circle(img, (int(x), int(y)), int(radius),(0, 255, 255), 2)\n\t\t\tcv2.circle(img, center, 5, (0, 0, 255), -1)\n\tpts.appendleft(center)\n\tfor i in range (1,len(pts)):\n\t\tif pts[i-1]is None or pts[i] is None:\n\t\t\tcontinue\n\t\tthick = int(np.sqrt(len(pts) / float(i + 1)) * 2.5)",
        "detail": "3",
        "documentation": {}
    },
    {
        "label": "\t\tcenter",
        "kind": 5,
        "importPath": "3",
        "description": "3",
        "peekOfCode": "\t\tcenter = (int(M[\"m10\"] / M[\"m00\"]), int(M[\"m01\"] / M[\"m00\"]))\n\t\tif radius > 5:\n\t\t\tcv2.circle(img, (int(x), int(y)), int(radius),(0, 255, 255), 2)\n\t\t\tcv2.circle(img, center, 5, (0, 0, 255), -1)\n\tpts.appendleft(center)\n\tfor i in range (1,len(pts)):\n\t\tif pts[i-1]is None or pts[i] is None:\n\t\t\tcontinue\n\t\tthick = int(np.sqrt(len(pts) / float(i + 1)) * 2.5)\n\t\tcv2.line(img, pts[i-1],pts[i],(0,0,225),thick)",
        "detail": "3",
        "documentation": {}
    },
    {
        "label": "\t\tthick",
        "kind": 5,
        "importPath": "3",
        "description": "3",
        "peekOfCode": "\t\tthick = int(np.sqrt(len(pts) / float(i + 1)) * 2.5)\n\t\tcv2.line(img, pts[i-1],pts[i],(0,0,225),thick)\n\tcv2.imshow(\"Frame\", img)\n\tcv2.imshow(\"mask\",mask)\n\tcv2.imshow(\"res\",res)\n\tk=cv2.waitKey(30) & 0xFF\n\tif k==32: \n\t\tbreak\n# cleanup the camera and close any open windows\ncap.release()",
        "detail": "3",
        "documentation": {}
    },
    {
        "label": "poseDetector",
        "kind": 6,
        "importPath": "4+",
        "description": "4+",
        "peekOfCode": "class poseDetector():\n    def __init__(self, mode=False, complex=1, smooth_landmarks=True, segmentation=True, smooth_segmentation=True,\n                 detectionCon=0.5, trackCon=0.5):\n        self.mode = mode\n        self.complex = complex\n        self.smooth_landmarks = smooth_landmarks\n        self.segmentation = segmentation\n        self.smooth_segmentation = smooth_segmentation\n        self.detectionCon = detectionCon\n        self.trackCon = trackCon",
        "detail": "4+",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "4+",
        "description": "4+",
        "peekOfCode": "def main():\n    cap = cv2.VideoCapture(\"..//assets//videos//v4.mp4\")\n    detector = poseDetector()\n    while True:\n        success, img = cap.read()\n        img = detector.findPose(img)\n        cv2.imshow(\"Image\", img)\n        cv2.waitKey(1)\nif __name__ == \"__main__\":\n    main()",
        "detail": "4+",
        "documentation": {}
    },
    {
        "label": "mp_drawing",
        "kind": 5,
        "importPath": "HandPoseDetect",
        "description": "HandPoseDetect",
        "peekOfCode": "mp_drawing = mp.solutions.drawing_utils\nmp_hands = mp.solutions.hands\nmp_pose = mp.solutions.pose\npose = mp_pose.Pose()\nlandmark_mapping = {\n    11: \"LEFT SHOULDER\",\n    12: \"RIGHT SHOULDER\",\n    13: \"LEFT ELBOW\",\n    14: \"RIGHT ELBOW\",\n    15: \"LEFT WRIST\",",
        "detail": "HandPoseDetect",
        "documentation": {}
    },
    {
        "label": "mp_hands",
        "kind": 5,
        "importPath": "HandPoseDetect",
        "description": "HandPoseDetect",
        "peekOfCode": "mp_hands = mp.solutions.hands\nmp_pose = mp.solutions.pose\npose = mp_pose.Pose()\nlandmark_mapping = {\n    11: \"LEFT SHOULDER\",\n    12: \"RIGHT SHOULDER\",\n    13: \"LEFT ELBOW\",\n    14: \"RIGHT ELBOW\",\n    15: \"LEFT WRIST\",\n    16: \"RIGHT WRIST\"",
        "detail": "HandPoseDetect",
        "documentation": {}
    },
    {
        "label": "mp_pose",
        "kind": 5,
        "importPath": "HandPoseDetect",
        "description": "HandPoseDetect",
        "peekOfCode": "mp_pose = mp.solutions.pose\npose = mp_pose.Pose()\nlandmark_mapping = {\n    11: \"LEFT SHOULDER\",\n    12: \"RIGHT SHOULDER\",\n    13: \"LEFT ELBOW\",\n    14: \"RIGHT ELBOW\",\n    15: \"LEFT WRIST\",\n    16: \"RIGHT WRIST\"\n}",
        "detail": "HandPoseDetect",
        "documentation": {}
    },
    {
        "label": "pose",
        "kind": 5,
        "importPath": "HandPoseDetect",
        "description": "HandPoseDetect",
        "peekOfCode": "pose = mp_pose.Pose()\nlandmark_mapping = {\n    11: \"LEFT SHOULDER\",\n    12: \"RIGHT SHOULDER\",\n    13: \"LEFT ELBOW\",\n    14: \"RIGHT ELBOW\",\n    15: \"LEFT WRIST\",\n    16: \"RIGHT WRIST\"\n}\nconnections = [",
        "detail": "HandPoseDetect",
        "documentation": {}
    },
    {
        "label": "landmark_mapping",
        "kind": 5,
        "importPath": "HandPoseDetect",
        "description": "HandPoseDetect",
        "peekOfCode": "landmark_mapping = {\n    11: \"LEFT SHOULDER\",\n    12: \"RIGHT SHOULDER\",\n    13: \"LEFT ELBOW\",\n    14: \"RIGHT ELBOW\",\n    15: \"LEFT WRIST\",\n    16: \"RIGHT WRIST\"\n}\nconnections = [\n    (11, 13),  # Left shoulder to left elbow",
        "detail": "HandPoseDetect",
        "documentation": {}
    },
    {
        "label": "connections",
        "kind": 5,
        "importPath": "HandPoseDetect",
        "description": "HandPoseDetect",
        "peekOfCode": "connections = [\n    (11, 13),  # Left shoulder to left elbow\n    (13, 15),  # Left elbow to left wrist\n    (12, 14),  # Right shoulder to right elbow\n    (14, 16),  # Right elbow to right wrist\n    (11, 12)   # Left shoulder to right shoulder\n]\n# For webcam input:\ncap = cv2.VideoCapture(0)\nwith mp_hands.Hands(",
        "detail": "HandPoseDetect",
        "documentation": {}
    },
    {
        "label": "cap",
        "kind": 5,
        "importPath": "HandPoseDetect",
        "description": "HandPoseDetect",
        "peekOfCode": "cap = cv2.VideoCapture(0)\nwith mp_hands.Hands(\n    min_detection_confidence=0.5,\n    min_tracking_confidence=0.5) as hands:\n  while cap.isOpened():\n    success, image = cap.read()\n    if not success:\n      print(\"Ignoring empty camera frame.\")\n      # If loading a video, use 'break' instead of 'continue'.\n      continue",
        "detail": "HandPoseDetect",
        "documentation": {}
    },
    {
        "label": "mp_drawing",
        "kind": 5,
        "importPath": "HandTracking",
        "description": "HandTracking",
        "peekOfCode": "mp_drawing = mp.solutions.drawing_utils\nmp_hands = mp.solutions.hands\n# For webcam input:\ncap = cv2.VideoCapture(0)\nwith mp_hands.Hands(\n    min_detection_confidence=0.5,\n    min_tracking_confidence=0.5) as hands:\n  while cap.isOpened():\n    success, image = cap.read()\n    if not success:",
        "detail": "HandTracking",
        "documentation": {}
    },
    {
        "label": "mp_hands",
        "kind": 5,
        "importPath": "HandTracking",
        "description": "HandTracking",
        "peekOfCode": "mp_hands = mp.solutions.hands\n# For webcam input:\ncap = cv2.VideoCapture(0)\nwith mp_hands.Hands(\n    min_detection_confidence=0.5,\n    min_tracking_confidence=0.5) as hands:\n  while cap.isOpened():\n    success, image = cap.read()\n    if not success:\n      print(\"Ignoring empty camera frame.\")",
        "detail": "HandTracking",
        "documentation": {}
    },
    {
        "label": "cap",
        "kind": 5,
        "importPath": "HandTracking",
        "description": "HandTracking",
        "peekOfCode": "cap = cv2.VideoCapture(0)\nwith mp_hands.Hands(\n    min_detection_confidence=0.5,\n    min_tracking_confidence=0.5) as hands:\n  while cap.isOpened():\n    success, image = cap.read()\n    if not success:\n      print(\"Ignoring empty camera frame.\")\n      # If loading a video, use 'break' instead of 'continue'.\n      continue",
        "detail": "HandTracking",
        "documentation": {}
    },
    {
        "label": "calculate_rolling_average",
        "kind": 2,
        "importPath": "RollinAvgOverSerial",
        "description": "RollinAvgOverSerial",
        "peekOfCode": "def calculate_rolling_average(new_value, window_size, rolling_values):\n    if len(rolling_values) < window_size:\n        rolling_values.append(new_value)\n    else:\n        rolling_values.popleft()\n        rolling_values.append(new_value)\n    return sum(rolling_values) / len(rolling_values)\n# Example usage\nwindow_size = 5\nrolling_values = deque(maxlen=window_size)",
        "detail": "RollinAvgOverSerial",
        "documentation": {}
    },
    {
        "label": "window_size",
        "kind": 5,
        "importPath": "RollinAvgOverSerial",
        "description": "RollinAvgOverSerial",
        "peekOfCode": "window_size = 5\nrolling_values = deque(maxlen=window_size)\n# Serial port configuration\nserial_port = serial.Serial('COM1', 9600)  # Adjust the port and baudrate as needed\ntry:\n    while True:\n        # Simulate new angle measurement (replace with actual sensor reading)\n        angle_measurement = 30  # Replace this line with your actual angle measurement\n        # Calculate rolling average\n        rolling_avg = calculate_rolling_average(angle_measurement, window_size, rolling_values)",
        "detail": "RollinAvgOverSerial",
        "documentation": {}
    },
    {
        "label": "rolling_values",
        "kind": 5,
        "importPath": "RollinAvgOverSerial",
        "description": "RollinAvgOverSerial",
        "peekOfCode": "rolling_values = deque(maxlen=window_size)\n# Serial port configuration\nserial_port = serial.Serial('COM1', 9600)  # Adjust the port and baudrate as needed\ntry:\n    while True:\n        # Simulate new angle measurement (replace with actual sensor reading)\n        angle_measurement = 30  # Replace this line with your actual angle measurement\n        # Calculate rolling average\n        rolling_avg = calculate_rolling_average(angle_measurement, window_size, rolling_values)\n        print(f\"New angle: {angle_measurement}, Rolling Average: {rolling_avg}\")",
        "detail": "RollinAvgOverSerial",
        "documentation": {}
    },
    {
        "label": "serial_port",
        "kind": 5,
        "importPath": "RollinAvgOverSerial",
        "description": "RollinAvgOverSerial",
        "peekOfCode": "serial_port = serial.Serial('COM1', 9600)  # Adjust the port and baudrate as needed\ntry:\n    while True:\n        # Simulate new angle measurement (replace with actual sensor reading)\n        angle_measurement = 30  # Replace this line with your actual angle measurement\n        # Calculate rolling average\n        rolling_avg = calculate_rolling_average(angle_measurement, window_size, rolling_values)\n        print(f\"New angle: {angle_measurement}, Rolling Average: {rolling_avg}\")\n        # Send rolling average value through serial port\n        serial_port.write(f\"{rolling_avg}\\n\".encode())",
        "detail": "RollinAvgOverSerial",
        "documentation": {}
    },
    {
        "label": "RollingAverageFilter",
        "kind": 6,
        "importPath": "poseLibrary",
        "description": "poseLibrary",
        "peekOfCode": "class RollingAverageFilter:\n    def __init__(self, window_size:int):\n        self.window_size = window_size\n        self.values = []\n    def add_value(self, value:float):\n        self.values.append(value)\n        if len(self.values) > self.window_size:\n            self.values.pop(0)\n    def get_filtered_value(self)->int:\n        if len(self.values) == 0:",
        "detail": "poseLibrary",
        "documentation": {}
    },
    {
        "label": "PoseDetector",
        "kind": 6,
        "importPath": "poseLibrary",
        "description": "poseLibrary",
        "peekOfCode": "class PoseDetector:\n    def __init__(self, window_size:int=100):\n        self.mp_pose = mp.solutions.pose\n        self.mp_draw = mp.solutions.drawing_utils\n        self.pose = self.mp_pose.Pose()\n        self.window_size = window_size\n        self.slopeContainer = []\n        self.slope = 0\n        self.prevSlope = 0\n        self.landmark_mapping = {",
        "detail": "poseLibrary",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "poseLibrary",
        "description": "poseLibrary",
        "peekOfCode": "def main():\n    # Initialize PoseDetector object\n    pose_detector = PoseDetector(window_size=10)\n    # Take video input for pose detection\n    cap = cv2.VideoCapture(0)  # You can put here video of your choice (\"sampleVideo.mp4\")\n    # Read each frame/image from capture object\n    while True:\n        ret, img = cap.read()\n        # Resize image/frame so we can accommodate it on our screen\n        img = cv2.resize(img, (640, 480))",
        "detail": "poseLibrary",
        "documentation": {}
    },
    {
        "label": "counter",
        "kind": 5,
        "importPath": "poseLibrary",
        "description": "poseLibrary",
        "peekOfCode": "counter = 0\n#-----------------------------------------------\nclass RollingAverageFilter:\n    def __init__(self, window_size:int):\n        self.window_size = window_size\n        self.values = []\n    def add_value(self, value:float):\n        self.values.append(value)\n        if len(self.values) > self.window_size:\n            self.values.pop(0)",
        "detail": "poseLibrary",
        "documentation": {}
    },
    {
        "label": "calculate_rolling_average",
        "kind": 2,
        "importPath": "rollingAvgExample",
        "description": "rollingAvgExample",
        "peekOfCode": "def calculate_rolling_average(new_value, window_size, rolling_values):\n    if len(rolling_values) < window_size:\n        rolling_values.append(new_value)\n    else:\n        rolling_values.popleft()\n        rolling_values.append(new_value)\n    return sum(rolling_values) / len(rolling_values)\n# Example usage\nwindow_size = 10\nrolling_values = deque(maxlen=window_size)",
        "detail": "rollingAvgExample",
        "documentation": {}
    },
    {
        "label": "window_size",
        "kind": 5,
        "importPath": "rollingAvgExample",
        "description": "rollingAvgExample",
        "peekOfCode": "window_size = 10\nrolling_values = deque(maxlen=window_size)\n# Simulating incoming angle measurements\nangle_measurements = [30, 35, 40, 45, 50, 55, 60, 65, 70, 75]\nfor angle in angle_measurements:\n    rolling_avg = calculate_rolling_average(angle, window_size, rolling_values)\n    print(f\"New angle: {angle}, Rolling Average: {rolling_avg}\")",
        "detail": "rollingAvgExample",
        "documentation": {}
    },
    {
        "label": "rolling_values",
        "kind": 5,
        "importPath": "rollingAvgExample",
        "description": "rollingAvgExample",
        "peekOfCode": "rolling_values = deque(maxlen=window_size)\n# Simulating incoming angle measurements\nangle_measurements = [30, 35, 40, 45, 50, 55, 60, 65, 70, 75]\nfor angle in angle_measurements:\n    rolling_avg = calculate_rolling_average(angle, window_size, rolling_values)\n    print(f\"New angle: {angle}, Rolling Average: {rolling_avg}\")",
        "detail": "rollingAvgExample",
        "documentation": {}
    },
    {
        "label": "angle_measurements",
        "kind": 5,
        "importPath": "rollingAvgExample",
        "description": "rollingAvgExample",
        "peekOfCode": "angle_measurements = [30, 35, 40, 45, 50, 55, 60, 65, 70, 75]\nfor angle in angle_measurements:\n    rolling_avg = calculate_rolling_average(angle, window_size, rolling_values)\n    print(f\"New angle: {angle}, Rolling Average: {rolling_avg}\")",
        "detail": "rollingAvgExample",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "utf",
        "description": "utf",
        "peekOfCode": "path = \"c:\\golder\\locatÄ±on\"\nprint(repr(path))",
        "detail": "utf",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "utils_v2",
        "description": "utils_v2",
        "peekOfCode": "def main():\n    hands = mp_hands.Hands(\n        min_detection_confidence=0.7, min_tracking_confidence=0.7)\n    hand_landmark_drawing_spec = mp_drawing.DrawingSpec(thickness=5, circle_radius=5)\n    hand_connection_drawing_spec = mp_drawing.DrawingSpec(thickness=10, circle_radius=10)\n    cap = cv2.VideoCapture(0)\n    pts = deque(maxlen=64)\n    while cap.isOpened():\n        idx_to_coordinates = {}\n        ret, image = cap.read()",
        "detail": "utils_v2",
        "documentation": {}
    },
    {
        "label": "mp_drawing",
        "kind": 5,
        "importPath": "utils_v2",
        "description": "utils_v2",
        "peekOfCode": "mp_drawing = mp.solutions.drawing_utils\nmp_hands = mp.solutions.hands\ndef main():\n    hands = mp_hands.Hands(\n        min_detection_confidence=0.7, min_tracking_confidence=0.7)\n    hand_landmark_drawing_spec = mp_drawing.DrawingSpec(thickness=5, circle_radius=5)\n    hand_connection_drawing_spec = mp_drawing.DrawingSpec(thickness=10, circle_radius=10)\n    cap = cv2.VideoCapture(0)\n    pts = deque(maxlen=64)\n    while cap.isOpened():",
        "detail": "utils_v2",
        "documentation": {}
    },
    {
        "label": "mp_hands",
        "kind": 5,
        "importPath": "utils_v2",
        "description": "utils_v2",
        "peekOfCode": "mp_hands = mp.solutions.hands\ndef main():\n    hands = mp_hands.Hands(\n        min_detection_confidence=0.7, min_tracking_confidence=0.7)\n    hand_landmark_drawing_spec = mp_drawing.DrawingSpec(thickness=5, circle_radius=5)\n    hand_connection_drawing_spec = mp_drawing.DrawingSpec(thickness=10, circle_radius=10)\n    cap = cv2.VideoCapture(0)\n    pts = deque(maxlen=64)\n    while cap.isOpened():\n        idx_to_coordinates = {}",
        "detail": "utils_v2",
        "documentation": {}
    }
]